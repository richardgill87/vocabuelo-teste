<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>VOCABUELO</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      background-color: #000; 
      color: #fff; 
      margin: 20px; 
    }
    .container { display: flex; gap: 20px; margin-top: 15px; }
    
    #nuvem { 
      flex: 3; 
      height: 600px; 
      border: 2px solid #fff; 
      background-color: #fff; 
      position: relative;
      overflow: hidden;
    }

    #historico-container { 
      flex: 1; 
      height: 600px; 
      overflow-y: auto; 
      border: 1px solid #444; 
      padding: 10px;
      background: #111;
    }

    /* Estilo dos NÃ³s e Linhas */
    .node circle {
      stroke: #000;
      stroke-width: 2px;
    }
    .node text {
      font-size: 12px;
      font-weight: bold;
      fill: #000;
      pointer-events: none;
    }
    line {
      stroke: #333 !important;
      stroke-width: 2.5px;
      stroke-opacity: 0.8;
    }

    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #333; padding: 8px; text-align: left; font-size: 14px; }
    th { color: #87cefa; }
    .sucesso { color: #4caf50; font-weight: bold; }
    .falha { color: #f44336; }
    
    input { padding: 8px; width: 250px; border-radius: 4px; border: none; }
	@keyframes pulsar {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.vitoria-anim {
  animation: pulsar 0.5s infinite;
}
  </style>
</head>
<body>

  <h1>VOCABUELO</h1>
<p id="objetivo" style="font-size: 1.2em; color: gold;"></p>

<div style="margin-bottom: 20px;">
    <label for="novaPalavra">Digite uma palavra:</label>
    <input id="novaPalavra" type="text" placeholder="Aperte Enter para enviar">
    <p id="resultado"></p>

    <div id="vitoria-actions" style="display:none; margin-top: 10px;">
      <button id="btnCompartilhar" onclick="compartilharResultado()" style="padding: 12px 25px; background-color: #4caf50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
        ðŸ“¤ Compartilhar Resultado
      </button>
    </div>
</div>

<div class="container">
    <div id="nuvem"></div>
    <div id="historico-container">
      <h3>HistÃ³rico</h3>
      <table id="tabela-historico">
        <thead>
          <tr>
            <th>Palavra</th>
            <th>Proximidade</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
</div>

  <script type="module">
    import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers/dist/transformers.min.js";
    
    let extractor = null;
    let dicionario = [];
    let inicio, fim, corrente = [];
    let nodes = [], links = [];
	// No inÃ­cio do seu cÃ³digo, onde ficam as variÃ¡veis globais
let correnteDePalavras = ["PalavraInicial"]; // ComeÃ§a com a primeira palavra

    // LIMPEZA E CRIAÃ‡ÃƒO DO SVG (Evita duplicatas)
    const nuvemDiv = d3.select("#nuvem");
    nuvemDiv.html(""); // Limpa qualquer resÃ­duo antes de comeÃ§ar
    
    const width = document.getElementById("nuvem").offsetWidth;
    const height = 600;

    const svg = nuvemDiv.append("svg")
      .attr("width", "100%")
      .attr("height", height);

    const svgGroup = svg.append("g");

    const zoom = d3.zoom()
      .scaleExtent([0.1, 5])
      .on("zoom", (event) => {
        svgGroup.attr("transform", event.transform);
      });
    svg.call(zoom);

    // SIMULAÃ‡ÃƒO FÃSICA
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).distance(80).id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-150))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("x", d3.forceX(width / 2).strength(0.05))
      .force("y", d3.forceY(height / 2).strength(0.05))
      .force("collision", d3.forceCollide().radius(35));

    let link = svgGroup.append("g").selectAll("line");
    let node = svgGroup.append("g").selectAll(".node");

    async function carregarModelo() {
      if (!extractor) {
        extractor = await pipeline("feature-extraction", "Xenova/all-MiniLM-L6-v2");
        document.getElementById("resultado").innerText = "Modelo pronto!";
      }
      return extractor;
    }

    async function carregarDicionario() {
      try {
        const resposta = await fetch("https://raw.githubusercontent.com/tiagope/todas-palavras-PT-BR/main/br-utf8.txt");
        const texto = await resposta.text();
        dicionario = texto.split("\n")
          .map(p => p.trim().toLowerCase())
          .filter(p => p.length >= 4 && p.length <= 10);
      } catch (e) {
        document.getElementById("resultado").innerText = "Erro no dicionÃ¡rio.";
      }
    }

    function cosineSimilarity(a, b) {
      const dot = a.reduce((acc, val, i) => acc + val * b[i], 0);
      const normA = Math.sqrt(a.reduce((acc, val) => acc + val * val, 0));
      const normB = Math.sqrt(b.reduce((acc, val) => acc + val * val, 0));
      return dot / (normA * normB);
    }

    function adicionarNo(palavra, embedding, pos) {
  // Define o centro como fallback de seguranÃ§a
  let posX = width / 2;
  let posY = height / 2;

  // Se houver uma posiÃ§Ã£o de referÃªncia vÃ¡lida, usa ela
  if (pos && typeof pos.x === 'number' && !isNaN(pos.x)) {
    posX = pos.x;
    posY = pos.y;
  }

  const novo = { 
    id: palavra, 
    embedding, 
    // Adiciona um pequeno "jitter" (espalhamento) para nÃ£o nascerem exatamente um sobre o outro
    x: posX + (Math.random() * 10 - 5), 
    y: posY + (Math.random() * 10 - 5) 
  };

  nodes.push(novo);
  atualizarNuvem();
}

    function atualizarNuvem() {
      link = link.data(links);
      link.exit().remove();
      link = link.enter().append("line").merge(link);

      node = node.data(nodes, d => d.id);
	  // Procure por algo como 'node = node.data(nodes...)' e insira abaixo:
node.select("circle")
  .style("fill", d => {
    if (d.id === inicio) return "yellow";
    if (d.id === fim) return "#50C878";

    const temConexao = links.some(l => 
      (typeof l.source === "object" ? l.source.id === d.id : l.source === d.id) || 
      (typeof l.target === "object" ? l.target.id === d.id : l.target === d.id)
    );

    return temConexao ? "red" : "#808080"; 
  });
      node.exit().remove();

      const nodeEnter = node.enter().append("g").attr("class", "node")
        .call(d3.drag()
          .on("start", (event, d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
          })
          .on("drag", (event, d) => {
            d.fx = event.x; d.fy = event.y;
          })
          .on("end", (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
          }));

nodeEnter.append("circle")
  .attr("r", 25)
  .style("stroke", "#000")
  .style("stroke-width", "2px")
  .style("fill", d => {
    // 1. InÃ­cio e Fim mantÃªm as cores originais
    if (d.id === inicio) return "yellow";
    if (d.id === fim) return "#50C878";
    
    // 2. Verifica se este nÃ³ possui algum link conectado a ele
    const temConexao = links.some(l => 
      (typeof l.source === "object" ? l.source.id === d.id : l.source === d.id) || 
      (typeof l.target === "object" ? l.target.id === d.id : l.target === d.id)
    );
    
    // 3. Se estiver conectado, fica VERMELHO. Se estiver solto, fica CINZA.
    return temConexao ? "red" : "#808080"; 
  });

      nodeEnter.append("text")
        .attr("dy", 4)
        .attr("text-anchor", "middle")
        .text(d => d.id);

      node = nodeEnter.merge(node);
      simulation.nodes(nodes);
      simulation.force("link").links(links);
      simulation.alpha(1).restart();
    }

    simulation.on("tick", () => {
      const radius = 25;
      node.attr("transform", d => {
        d.x = Math.max(radius, Math.min(width - radius, d.x));
        d.y = Math.max(radius, Math.min(height - radius, d.y));
        return `translate(${d.x},${d.y})`;
      });
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    });

    async function adicionarPalavra() {
      await carregarModelo();
      const input = document.getElementById("novaPalavra");
      const novaPalavra = input.value.trim().toLowerCase();
      const minPalavras = 4;

      if (!dicionario.includes(novaPalavra) || corrente.includes(novaPalavra)) {
        document.getElementById("resultado").innerText = "InvÃ¡lida ou jÃ¡ usada!";
        return;
      }

      const output = await extractor(novaPalavra, { pooling: "mean", normalize: true });
      const vetorNova = output.data;

      let maiorSim = -1;
      let noMaisProximo = nodes[0];

      nodes.forEach(no => {
        const sim = cosineSimilarity(vetorNova, no.embedding) * 100;
        if (sim > maiorSim) { maiorSim = sim; noMaisProximo = no; }
      });

      const tabela = document.querySelector("#tabela-historico tbody");
      const novaLinha = tabela.insertRow(0);
      novaLinha.innerHTML = `<td>${novaPalavra}</td><td class="${maiorSim >= 40 ? 'sucesso' : 'falha'}">${maiorSim.toFixed(1)}%</td>`;

adicionarNo(novaPalavra, vetorNova, { x: noMaisProximo.x, y: noMaisProximo.y });
      corrente.push(novaPalavra);

      let conectou = false;
      nodes.forEach(no => {
        if (no.id === novaPalavra) return;
        const sim = cosineSimilarity(vetorNova, no.embedding) * 100;
        if (sim >= 40) {
          if (no.id === fim && corrente.length < minPalavras) {
             document.getElementById("resultado").innerText = "Perto do fim! Precisa de mais palavras.";
          } else {
             links.push({ source: no.id, target: novaPalavra });
             conectou = true;
          }
        }
      });

      document.getElementById("resultado").innerText = conectou ? "Conectada!" : "Palavra solta.";
      atualizarNuvem();
	  // Isso forÃ§a a atualizaÃ§Ã£o das cores de todos os cÃ­rculos existentes
node.selectAll("circle").style("fill", d => {
  if (d.id === inicio) return "yellow";
  if (d.id === fim) return "#50C878";
  const temConexao = links.some(l => 
    (typeof l.source === "object" ? l.source.id === d.id : l.source === d.id) || 
    (typeof l.target === "object" ? l.target.id === d.id : l.target === d.id)
  );
  // Durante o jogo, conectado fica Azul Claro
  return temConexao ? "#87cefa" : "#808080"; 
});
      input.value = "";

      // Verifica vitÃ³ria
  if (existeLigacao(inicio, fim, links) && corrente.length >= minPalavras) {
    document.getElementById("resultado").innerText = "ðŸŽ‰ INCRÃVEL! VOCÃŠ CONECTOU A PONTE!";
	
	document.getElementById("vitoria-actions").style.display = "block";
    
    // 1. AnimaÃ§Ã£o do Fundo: O retÃ¢ngulo branco brilha em dourado/amarelo claro
    d3.select("#nuvem")
      .transition()
      .duration(1000)
      .style("background-color", "#fff9c4") // Um amarelo bem clari nho
      .transition()
      .duration(1000)
      .style("background-color", "#f0fdf4"); // Um verde vitÃ³ria suave

   // 2. AnimaÃ§Ã£o dos BalÃµes: TransiÃ§Ã£o para Vermelho e DegradÃª
const escalaVitoria = d3.interpolateRgb("gold", "red"); // InÃ­cio amarelo, caminho vermelho
const escalaFinal = d3.interpolateRgb("red", "#2ecc71"); // Caminho vermelho para fim verde

node.selectAll("circle")
  .transition()
  .duration(1000)
  .style("fill", d => {
    // Se for inÃ­cio ou fim, mantemos as cores destaque
    if (d.id === inicio) return "yellow";
    if (d.id === fim) return "#50C878";

    // Verifica se a palavra estÃ¡ na corrente de vitÃ³ria
    const temConexao = links.some(l => 
      (typeof l.source === "object" ? l.source.id === d.id : l.source === d.id) || 
      (typeof l.target === "object" ? l.target.id === d.id : l.target === d.id)
    );

    // Se estiver conectada na vitÃ³ria, fica Vermelha!
    return temConexao ? "red" : "#444"; 
  })
  .style("stroke", "white")
  .style("stroke-width", "3px");

    // 3. AnimaÃ§Ã£o das Linhas: As conexÃµes brilham
    link.transition()
      .duration(800)
      .style("stroke", "#ff9800")
      .style("stroke-width", "5px");

    // MantÃ©m a fÃ­sica suave e depois para
    simulation.alphaTarget(0.2).restart();
    if (typeof focarGeral === "function") focarGeral();

    setTimeout(() => { 
      simulation.stop(); 
    }, 3000);
  }
    }

    function existeLigacao(inicio, fim, links) {
      const adj = {};
      links.forEach(l => {
        const u = typeof l.source === "object" ? l.source.id : l.source;
        const v = typeof l.target === "object" ? l.target.id : l.target;
        if(!adj[u]) adj[u] = []; if(!adj[v]) adj[v] = [];
        adj[u].push(v); adj[v].push(u);
      });
      const q = [inicio], vis = new Set([inicio]);
      while(q.length){
        const curr = q.shift();
        if(curr === fim) return true;
        (adj[curr] || []).forEach(n => { if(!vis.has(n)){ vis.add(n); q.push(n); }});
      }
      return false;
    }

    window.addEventListener("DOMContentLoaded", async () => {
  await carregarDicionario();
  await carregarModelo();
  
  inicio = dicionario[Math.floor(Math.random() * dicionario.length)];
  fim = dicionario[Math.floor(Math.random() * dicionario.length)];
  
  const embI = (await extractor(inicio, { pooling: "mean", normalize: true })).data;
  const embF = (await extractor(fim, { pooling: "mean", normalize: true })).data;

  // ForÃ§amos as coordenadas iniciais para evitar o canto (0,0)
  adicionarNo(inicio, embI, { x: width * 0.25, y: height / 2 });
  adicionarNo(fim, embF, { x: width * 0.75, y: height / 2 });

  corrente = [inicio];
  document.getElementById("objetivo").innerText = `Conecte "${inicio}" atÃ© "${fim}"`;
});

    document.getElementById("novaPalavra").addEventListener("keydown", e => { if(e.key === "Enter") adicionarPalavra(); });
	
	// Cole isto antes do final do seu
    // Tem que ter o "window." para o botÃ£o do HTML conseguir achar a funÃ§Ã£o
window.compartilharResultado = function() {
  const numPalavras = corrente.length;
  const linkBase = window.location.href; // Isso pega o link do seu site automaticamente
  
  const textoParaCopiar = `Joguei VOCABUELO â›“ï¸\n\n` +
    `Conectei "${inicio.toUpperCase()}" a "${fim.toUpperCase()}"\n` +
    `ðŸ§© Caminho: ${numPalavras} palavras\n` +
    `âœ¨ Tente vencer vocÃª tambÃ©m:\n` +
    `${linkBase}`;

  if (navigator.share) {
    navigator.share({ text: textoParaCopiar }).catch(console.error);
  } else {
    navigator.clipboard.writeText(textoParaCopiar).then(() => {
      alert("Resultado copiado! Agora Ã© sÃ³ colar no WhatsApp! ðŸš€");
    });
  }
}
  </script>
</body>
</html>
